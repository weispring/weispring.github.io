<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Content-Type]]></title>
    <url>%2F2018%2F01%2F27%2FContent-Type%2F</url>
    <content type="text"><![CDATA[Content-TypeMediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 类型格式：type/subtype(;parameter)? type主类型,如text，如果是号代表所有；subtype 子类型,如html，如果是号代表所有；parameter 可选，一些参数，如Accept请求头的q参数,Content-Type的 charset参数。例如： Content-Type: text/html;charset:utf-8; 常见的媒体格式类型如下：• text/html ： HTML格式• text/plain ：纯文本格式• text/xml ： XML格式• image/gif ：gif图片格式• image/jpeg ：jpg图片格式• image/png：png图片格式 以application开头的媒体格式类型：• application/xhtml+xml ：XHTML格式• application/xml ： XML数据格式• application/atom+xml ：Atom XML聚合格式• application/json ： JSON数据格式• application/pdf ：pdf格式• application/msword ： Word文档格式• application/octet-stream ： 二进制流数据（如常见的文件下载）• application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的：• multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。 Spring MVC中关于关于Content-Type类型信息的使用首先我们来看看RequestMapping中的Class定义：123456789101112@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Mapping public @interface RequestMapping &#123; String[] value() default &#123;&#125;; RequestMethod[] method() default &#123;&#125;; String[] params() default &#123;&#125;; String[] headers() default &#123;&#125;; String[] consumes() default &#123;&#125;; String[] produces() default &#123;&#125;; &#125; value: 指定请求的实际地址， 比如 /action/info之类。method： 指定请求的method类型， GET、POST、PUT、DELETE等consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回params： 指定request中必须包含某些参数值是，才让该方法处理headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。 Content-disposition(一般文件下载时候用)是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。（请注意，这是设计导致的；无法使用此功能将文档保存到用户的计算机上，而不向用户询问保存位置。）Content-Disposition就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名。具体的定义 那么由上可知具体的例子：Content-Disposition: attachment; filename=“filename.xls”当然filename参数可以包含路径信息，但User-Agnet会忽略掉这些信息，只会把路径信息的最后一部分做为文件名。当你在响应类型为application/octet- stream情况下使用了这个头信息的话，那就意味着你不想直接显示内容，而是弹出一个”文件下载”的对话框，接下来就是由你来决定“打开”还是“保存”了。如:Response.AppendHeader(“Content-Disposition”,”attachment;filename=MyExcel.xls”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>content-type</tag>
        <tag>header</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成二维码]]></title>
    <url>%2F2018%2F01%2F20%2F%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[近来客户资料需要归档，用二维码来存储一些信息，为此特学习了二维码如何生成。 1. 需要的依赖如下12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; 2. 二维码示例可以加logo，也可以画上一些文字 3. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.Image;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import java.util.UUID;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.WriterException;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import com.google.zxing.qrcode.encoder.ByteMatrix;import com.google.zxing.qrcode.encoder.Encoder;import com.google.zxing.qrcode.encoder.QRCode;public class QrCode &#123; static final int BLACK = 0xFF000000; static final int WHITE = 0xFFFFFFFF; static final int QUIET_ZONE_SIZE = 4;// 边框大小参数 public static void main(String[] args) throws IOException, WriterException &#123; String text = &quot;C:\\springboot-tomcat-tmp\\upload\\QRCode\\20180119&quot;; writeToStreamEntire(text, 500, 500, &quot;&quot;, &quot;&quot;, null); &#125; public static void writeToStreamEntire(String text, int width, int height, String format, String newPath, Object o) throws IOException, WriterException &#123; String p = &quot;C:\\springboot-tomcat-tmp\\upload\\QRCode\\20180119&quot;; //图片生成后的路径 newPath = p + File.separator + UUID.randomUUID() + &quot;.jpg&quot;; //预设置二维码大小 非实际值 width = 200; height = 200; System.out.println(&quot;writeToStreamEntire 入参: &quot; + &quot;text : &quot; + text + &quot; ,width=&quot; + width + &quot;,height=&quot; + height + &quot; ,format=&quot; + format + &quot;,newPath=&quot; + newPath); Hashtable&lt;EncodeHintType, String&gt; hints = new Hashtable&lt;EncodeHintType, String&gt;(); hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;); // 内容所使用字符集编码 hints.put(EncodeHintType.ERROR_CORRECTION, &quot;Q&quot;);// 容错率 共四种级别 BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints); // 用户获取偏移 二维码 空白部分的偏移 Map&lt;String, Integer&gt; xy = getXY(text, BarcodeFormat.QR_CODE, width, height, hints); // 二维码实际大小 包括边框 int widthR = bitMatrix.getWidth(); int heightR = bitMatrix.getHeight(); // 图片实际像素大小 实际的大小不能小于 二维码输出的大小 否则 扫不出来 int outHight = heightR + 500; int outWidth = widthR + 500; BufferedImage image = new BufferedImage(outWidth, outHight, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; outWidth; x++) &#123; for (int y = 0; y &lt; outHight; y++) &#123; if (x &lt; widthR &amp;&amp; y &lt; heightR) &#123; image.setRGB(x, y, bitMatrix.get(x, y) ? BLACK : WHITE); &#125; else &#123; image.setRGB(x, y, WHITE); &#125; &#125; &#125; FileOutputStream stream = null; // 中间加 个人图片 Graphics2D gs = image.createGraphics(); int ratioWidth = widthR * 2 / 10; int ratioHeight = heightR * 2 / 10; // 载入logo String logoPath = &quot;C:\\Users\\lixia\\Desktop\\java\\毕业季\\me.jpg&quot;; Image img = ImageIO.read(new File(logoPath)); int logoWidth = img.getWidth(null) &gt; ratioWidth ? ratioWidth : img.getWidth(null); int logoHeight = img.getHeight(null) &gt; ratioHeight ? ratioHeight : img.getHeight(null); int x = (widthR - logoWidth) / 2; int y = (heightR - logoHeight) / 2; gs.drawImage(img, x, y, logoWidth, logoHeight, null); gs.setColor(Color.black); gs.setBackground(Color.WHITE); gs.dispose(); img.flush(); try &#123; stream = new FileOutputStream(newPath); if (!ImageIO.write(image, &quot;jpg&quot;, stream)) &#123; throw new IOException(&quot;Could not write an image of format &quot; + format); &#125; // stream.write(&quot;四大地方地方&quot;.getBytes()); &#125; finally &#123; if (stream != null) &#123; stream.close(); &#125; &#125; try &#123; // 读取原图片信息 File srcImgFile = new File(newPath); Image srcImg = ImageIO.read(srcImgFile); int srcImgWidth = srcImg.getWidth(null); int srcImgHeight = srcImg.getHeight(null); // 加水印 加工生成的图片 BufferedImage bufImg = new BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = bufImg.createGraphics(); // 将生成的图片 读取出来 花在新的 图片对象上 若宽和高于图片本身不一致，则进行缩放 画到新的图片对象中 g.drawImage(srcImg, 0, 0, widthR, heightR, null); // 设置字体大小 // 根据最小字体大小设置 int min = widthR &gt; heightR ? heightR : widthR; int fontSize = (heightR - xy.get(&quot;Y&quot;) * 2) / 6; Font font = new Font(&quot;宋体&quot;, Font.PLAIN, fontSize - fontSize * 2 / 10); g.setColor(Color.white); // 根据图片的背景设置水印颜色 g.setFont(font); // 设置右边偏移 int rightX = widthR + widthR * 2 / 10; int rightY = xy.get(&quot;Y&quot;) + fontSize - fontSize * 2 / 10; g.drawString(&quot;客户姓名：&quot; + &quot;李显春&quot;, rightX, rightY); g.drawString(&quot;业务类型：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 1); g.drawString(&quot;品牌：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 2); g.drawString(&quot;车牌号：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 3); g.drawString(&quot;管理类型：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 4); g.drawString(&quot;档案管理：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 5); // 设置下边偏移 int downX = xy.get(&quot;X&quot;); int downY = heightR + heightR * 2 / 10; g.drawString(&quot;档案编号：&quot; + &quot;李显春&quot;, downX, downY); g.drawString(&quot;合同号：&quot; + &quot;CPHZ20170504N000007&quot;, downX, downY + fontSize * 1); g.drawString(&quot;车架号：&quot; + &quot;HT20170408CG0004&quot;, downX, downY + fontSize * 2); g.drawString(&quot;资料清单：&quot; + &quot;归档资料（售后回租个人）&quot;, downX, downY + fontSize * 3); g.drawString(&quot;经销商名称：&quot; + &quot;woshi&quot;, downX, downY + fontSize * 4); g.dispose(); // 输出图片 FileOutputStream outImgStream = new FileOutputStream(newPath); ImageIO.write(bufImg, &quot;jpg&quot;, outImgStream); outImgStream.flush(); outImgStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 获取偏移 public static Map&lt;String, Integer&gt; getXY(String contents, BarcodeFormat format, int width, int height, Map&lt;EncodeHintType, ?&gt; hints) throws WriterException &#123; if (contents.isEmpty()) &#123; throw new IllegalArgumentException(&quot;Found empty contents&quot;); &#125; if (format != BarcodeFormat.QR_CODE) &#123; throw new IllegalArgumentException(&quot;Can only encode QR_CODE, but got &quot; + format); &#125; if (width &lt; 0 || height &lt; 0) &#123; throw new IllegalArgumentException(&quot;Requested dimensions are too small: &quot; + width + &apos;x&apos; + height); &#125; ErrorCorrectionLevel errorCorrectionLevel = ErrorCorrectionLevel.L; int quietZone = QUIET_ZONE_SIZE; if (hints != null) &#123; if (hints.containsKey(EncodeHintType.ERROR_CORRECTION)) &#123; errorCorrectionLevel = ErrorCorrectionLevel .valueOf(hints.get(EncodeHintType.ERROR_CORRECTION).toString()); &#125; if (hints.containsKey(EncodeHintType.MARGIN)) &#123; quietZone = Integer.parseInt(hints.get(EncodeHintType.MARGIN).toString()); &#125; &#125; QRCode code = Encoder.encode(contents, errorCorrectionLevel, hints); ByteMatrix input = code.getMatrix(); if (input == null) &#123; throw new IllegalStateException(); &#125; int inputWidth = input.getWidth(); int inputHeight = input.getHeight(); int qrWidth = inputWidth + (quietZone * 2); int qrHeight = inputHeight + (quietZone * 2); int outputWidth = Math.max(width, qrWidth); int outputHeight = Math.max(height, qrHeight); int multiple = Math.min(outputWidth / qrWidth, outputHeight / qrHeight); int leftPadding = (outputWidth - (inputWidth * multiple)) / 2; int topPadding = (outputHeight - (inputHeight * multiple)) / 2; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;X&quot;, leftPadding); map.put(&quot;Y&quot;, topPadding); return map; &#125;&#125; 4. 注意与总结 1 理论上来讲，二维码是限的，就从图片上的点数也可以发现，不过数量应该巨大，还不知道是如何编码解析的。 2 生成的二维码大小和边框是自动计算的，不能手动设置。 3 二维码是有容错率的，即使部分丢失，也是可以扫出来的，因为编码有冗余。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle sql 总结]]></title>
    <url>%2F2018%2F01%2F11%2Foracle%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[oracle 常用查询– 子查询 ,在个别字段需要特殊处理的时候，这种子查询用起来特别好 select a.*, (select max(b.request_attachment_id) from tlb_request_to_attachment b where b.p_attachment_id = a.attachment_id) from tc_attachment a – decode 与 case when – 可以用在 三表关联– 可以看成都是对值进行编码,都只是单列处理,不同的是，case when 可以跟子查询，而decode 不能 ，因为decode 是函数 SELECT A.* ,DECODE (A.TLB_TYPE ,’1’,B.NAME ,’2’,C.NAME,NULL) FROM TLB_CARS_LIST_DETAIL ALEFT JOIN TLB_REQUEST_PERSONAL B ON A.TLB_ID = B.TLB_IDLEFT JOIN TLB_REQUEST_BIG_CUSTOMER C ON A.TLB_ID = C.TLB_ID SELECT CASE UNION_ID WHEN ‘700’ THEN ‘1’ WHEN ‘710’ THEN (SELECT PERSON_ID FROM TB_CFS_AUDITGROUP_PERSON_UNION U WHERE U.UNION_ID = A.UNION_ID ) ELSE ‘3’ END FROM TB_CFS_AUDITGROUP_PERSON_UNION A – 两表关联查询 存在不存在SELECT A.*,CASE when B.PERSON_ID IS NULL THEN ‘0’ ELSE ‘1’ END IS_IN FROM TB_CFS_AUDIT_GROUP_PERSON A LEFT JOIN TB_CFS_AUDITGROUP_PERSON_UNION B ON ( A.PERSON_ID=B.PERSON_IDAND GROUP_ID =211 ) SELECT A.*,CASE when A.PERSON_ID = ANY (SELECT PERSON_ID FROM TB_CFS_AUDITGROUP_PERSON_UNION U WHERE U.GROUP_ID =B.GROUP_ID ) THEN ‘0’ ELSE ‘1’ END IS_IN FROM TB_CFS_AUDIT_GROUP_PERSON A LEFT JOIN TB_CFS_AUDITGROUP_PERSON_UNION B ON ( A.PERSON_ID=B.PERSON_IDAND GROUP_ID =211 ) – 自连接 去重 或是 exist– 查找只有单条记录无对应的下一步记录，第二种是自连接实现的剔除，有点low select * from tba_agent_bail_detail a where not exists (select 1 from tba_agent_bail_detail where a.business_id = business_id and a.business_type = business_type and a.bail_detail_id != bail_detail_id and a.bail_type = bail_type and a.bail_amount = bail_amount) and a.bail_type in (‘3’, ‘4’) and a.bail_flag = ‘1’ and business_type in (‘TLB_REQUEST_PERSONAL’, ‘TLB_REQUEST_BIG_CUSTOMER’); select * from (select a.bail_detail_id, a.business_type, a.business_id, a.bail_type, a.bail_flag, a.bail_amount, a.agent_id, a.remark, to_char(a.create_date, ‘yyyy-mm-dd’) create_date, (case when a.bail_type = 3 then b.GPS_DEPOSIT_LEVERAGE else b.ACCESS_DEPOSIT_LEVERAGE end) AS “DEPOSIT_LEVERAGE”, c.agent_name, d.user_name, d.tlb_code, d.contract_number, to_char(d.apply_final_time, ‘yyyy-mm-dd’) apply_final_time, to_char(d.apply_down_time, ‘yyyy-mm-dd’) apply_down_time, d.vehicle_category, d.APPLY_STATUES from tba_agent_bail_detail a left join tba_agent_bail b on b.agent_id = a.agent_id left join tdl_agent_apply c on c.agent_id = a.agent_id left join TLB_REQUEST_PERSONAL d on d.tlb_id = a.business_id where a.business_type = ‘TLB_REQUEST_PERSONAL’ and a.bail_flag in (‘1’, ‘2’) union all select a.bail_detail_id, a.business_type, a.business_id, a.bail_type, a.bail_flag, a.bail_amount, a.agent_id, a.remark, to_char(a.create_date, ‘yyyy-mm-dd’) create_date, (case when a.bail_type = 3 then b.GPS_DEPOSIT_LEVERAGE else b.ACCESS_DEPOSIT_LEVERAGE end) as “DEPOSIT_LEVERAGE”, c.agent_name, d.name as user_name, d.tlb_code, d.contract_number, to_char(d.apply_final_time, ‘yyyy-mm-dd’) apply_final_time, to_char(d.apply_down_time, ‘yyyy-mm-dd’) apply_down_time, d.vehicle_category, d.APPLY_STATUES from tba_agent_bail_detail a left join tba_agent_bail b on b.agent_id = a.agent_id left join tdl_agent_apply c on c.agent_id = a.agent_id left join TLB_REQUEST_BIG_CUSTOMER d on d.tlb_id = a.business_id where a.business_type = ‘TLB_REQUEST_BIG_CUSTOMER’ and a.bail_flag in (‘1’, ‘2’)) t where to_number(trim(t.APPLY_STATUES)) &gt;= 419 AND bail_detail_id NOT IN (SELECT A.BAIL_DETAIL_ID FROM TBA_AGENT_BAIL_DETAIL A JOIN TBA_AGENT_BAIL_DETAIL B ON A.BUSINESS_ID = B.BUSINESS_ID AND A.BUSINESS_TYPE = B.BUSINESS_TYPE AND A.BAIL_TYPE = B.BAIL_TYPE AND A.BAIL_AMOUNT = B.BAIL_AMOUNT AND A.BAIL_DETAIL_ID &lt;&gt; B.BAIL_DETAIL_ID AND A.BAIL_FLAG = ‘1’) AND AGENT_ID = 1533 AND BAIL_FLAG = ‘1’ order by business_type, to_number(business_id), bail_flag, bail_amount – 树 – 查询父节点 根据子节点查找父节点select *from tb_value_list_detailsstart with ( details_id = ‘1361’ )connect by prior p_father_id= details_id – 查询子节点 根据父节点查找子节点 select *from tb_value_list_detailsstart with ( details_id = ‘1361’ )connect by p_father_id= prior details_id – 拼接字符串 成为一列类似于行转列 ,两个函数都有字符数限制,但listagg还可以实现排序 拼接SELECT REPLACE(listagg(TAG_NAME, ‘,’) within group(order by to_number(tag_up_id)), ‘,’, ‘&gt;’) AS TAG_NAME FROM TCM_TAG a where tag_level &gt; 1 START WITH TAG_ID = ‘52’ CONNECT BY PRIOR TAG_UP_ID = TAG_ID SELECT REPLACE(wm_concat(TAG_NAME) ‘,’, ‘&gt;’) AS TAG_NAMEFROM TCM_TAG awhere tag_level &gt; 1START WITH TAG_ID = ‘52’CONNECT BY PRIOR TAG_UP_ID = TAG_ID –查询被锁对象和解锁select object_name,machine,s.sid,s.serial#,L.OS_USER_NAMEfrom v$locked_object l,dba_objects o ,v$session swhere l.object_id = o.object_id and l.session_id=s.sid; 解锁alter system kill session ‘sid,serial#’ – 动态sql拼接，就是相当于单引号内 两个单引号表示一个单引号1 字符串拼接declarev_count number default 0;v_id varchar(36);v_sql varchar(1000);begin dbms_output.put_line(‘测试 sql in 不能接受多值的情况’);v_id :=’’’7797’’,’’1109’’’;v_id :=’’’7797’’,’’10000’’’;dbms_output.put_line(‘v_id: ‘||v_id);v_sql :=’ select count(1) from tc_attachment where attachment_id in (‘||v_id||’)’;execute immediate v_sql into v_count/ using v_id/; –dbms_output.put_line(‘v_count: ‘||v_count||’—-‘||v_sql); end; 2 函数实现使用 ASCII 编码，单引号 ‘ 的编码是39，所以拼接字符串可以这样写str := ‘select * from user where name=’||chr(39)||zhangsan||chr(39)||’ order by id’; oracle in 查询需要注意 – 存在select 1 from dual where 1 in (1,null) – 不存在 ,查询结果为空select 1 from dual where 1 not in (2,null) 函数1 – 为空时设置默认值 select nvl(‘ddd’,11) from dual 2 – 为值编码或转义 select decode(1,2,22) from dual 3 – 统计 count4 – 求和 sum 5 – 分组 group by 6 – 字符串转换函数 to_char select to_char(sysdate,’yyyy”-“mm-dd HH24”时”:mi:ss’) from dual7 – 时间转换函数 to_date select to_date (‘2017-09-01’,’yyyy-mm-dd’) from dual 8 – 差集 从集合去掉完全一样的 minus (select from ) minus (select from ) 9 取并集 union all 10 – 去重，对比结果的所有字段 distinct 给列取别名 – oracle 不区分大小写select 33 as ee from dualselect 33 as ee from dualselect 33 “from” from dual –# Mysql 默认区分大小写，可以配置为不区分select 11 LOW from dualselect 11 low from dualselect 11 from from dual]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[task学习]]></title>
    <url>%2F2018%2F01%2F10%2FgradleTask%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[java代码写在脚本中gradle构建脚本本可以写java代码，groove语言支持java代码 java 类定义 1234567891011121314151617181920212223242526public class VersionEntity &#123; private Integer major; private Integer minor; private boolean release; @Override public String toString() &#123; return &quot;VersionEntity [major=&quot; + major + &quot;, minor=&quot; + minor + &quot;, release=&quot; + release + &quot;]&quot;; &#125; public VersionEntity(Integer major, Integer minor, boolean release) &#123; super(); this.major = major; this.minor = minor; this.release = release; &#125; public VersionEntity() &#123; super(); this.major = 2121; &#125; &#125; 定义属性文件ext.f = file(“version.properties”); java 方法定义 123456789VersionEntity GenerateVersion() throws FileNotFoundException, IOException&#123; Properties properties = new Properties(); properties.load(new FileInputStream(f)); return new VersionEntity(Integer.valueOf(properties.get(&quot;major&quot;).toString()),Integer.valueOf(properties.get(&quot;minor&quot;).toString()), properties.getProperty(&quot;release&quot;).toString().equals(&quot;false&quot;));&#125; 调用project的task方法创建继承于defaultTask的task 1234567891011121314151617task ver &#123; /*直接调用java方法*/ project.version = GenerateVersion() version.release = true /*配置代码块中定义 输入 输出，定义的task便能执行增量式构建*/ inputs.property(&apos;release&apos;,version.release) outputs.file f doLast &#123; println project.version ant.propertyfile(file: f)&#123; /*修改属性文件中的值*/ entry(key: &apos;release&apos;,type: &apos;string&apos;,operation: &apos;=&apos;,value: &apos;true&apos;) println &apos;ver执行&apos; &#125; println project.version &#125; &#125; 自定义task类自定义task 类 也可以在java代码中定义，不过需要导入相应的包，此处gradle已经提供 12345678910111213141516171819202122class myDefaultTask extends DefaultTask &#123; /* 使用注解标识 输入 输出*/ @Input String pi @OutputDirectory po myDefaultTask ()&#123; group = &apos;定义task&apos; description = &apos;定义task,封装实现，只提供输入输出&apos; &#125; /*定义动作*/ @TaskAction void start() &#123; /*这里定义逻辑*/ println &apos;输入的是：&apos;+pi &#125;&#125; 测试增量式构建 1234567task ceShiMyDefaultTask(type: myDefaultTask)&#123; /*输入输出不变时，不在执行task*/ pi = &apos;hahhh--900&apos; po= file(&quot;/lib&quot;) doLast &#123;println &apos;ceShiMyDefaultTask&apos;&#125; &#125; 文件复制，可以参考api中Copy类这种文件复制 类似于 调用方法 123456789 task ccc()&#123; doLast&#123; copy() &#123; /* from into 都是copy对象的方法*/ from &quot;lib&quot; into &quot;test&quot; &#125; &#125;&#125; 这种文件复制 类似于继承 输入输出定义在父类中 此task执行一次就不会执行了123456789101112task hhh(type: Copy)&#123; inputs.property(&apos;release&apos;,11) outputs.dir file(&quot;111&quot;) doLast &#123; println &apos;-----------------------00000&apos; &#125; from &quot;111&quot; into &quot;2222&quot; include &quot;111.png&quot;&#125; task规则简单task只需project的task即可以添加，但是task规则只能通过taskContainer容器的addRule(String,Closure)方法 12345678910111213141516171819tasks.addRule(&apos;Pattern: Test&lt;Classifier&gt;My: 测试task规则.&apos;)&#123; String taskName -&gt; if (taskName.startsWith(&apos;Test&apos;) &amp;&amp; taskName.endsWith(&apos;My&apos;))&#123; task (taskName) &#123; doLast&#123; String classifier = taskName - &apos;Test&apos; - &apos;My&apos; switch(classifier)&#123; case &apos;1&apos; : println &apos;任务---1&apos; break case &apos;2&apos; : println &apos;任务---2&apos; break default: println &apos;任务000&apos; &#125; &#125; &#125; &#125;&#125; 编写生命周期钩子，类似于监听，事件是任务蓝图创建完成后12345678910 gradle.taskGraph.whenReady &#123;taskGraph -&gt; /*包含不一定执行动作，一定执行配置，因为有可能是最新的，*/ if(taskGraph.hasTask(&apos;:addTask&apos;)) &#123; println &apos; 存在的逻辑&apos; &#125; else &#123; println &apos; 不存在的逻辑&apos; &#125; &#125; 不依赖依赖的task，控制执行顺序1 finalizedBy就是在task执行完之后要执行的task。 2 mustRunAfter并不会添加依赖，它只是告诉Gradle执行的优先级如果两个task同时存在 总结 重点把握对生命周期、执行顺序的认识 借助gradle插件库查看源码，进行学习]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误集]]></title>
    <url>%2F2018%2F01%2F10%2F%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[常见错误处理解决The hierarchy of the type is inconsistent错误 可能的原因：自己的类继承于某个类，这个类或者这个类继承的类或者再往上继承的某个类所在的jar包没有被引入。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学Gradle Task]]></title>
    <url>%2F2018%2F01%2F09%2Fgradle-Task%2F</url>
    <content type="text"><![CDATA[脚本默认taskBuild Setup tasksinit - Initializes a new Gradle build. [incubating]wrapper - Generates Gradle wrapper files. [incubating] Help tasksbuildEnvironment - Displays all buildscript dependencies declared in root project ‘learn’.components - Displays the components produced by root project ‘learn’. [incubating]dependencies - Displays all dependencies declared in root project ‘learn’.dependencyInsight - Displays the insight into a specific dependency in root project ‘learn’.dependentComponents - Displays the dependent components of components in root project ‘learn’. [incubating]help - Displays a help message.model - Displays the configuration model of root project ‘learn’. [incubating]projects - Displays the sub-projects of root project ‘learn’.properties - Displays the properties of root project ‘learn’.tasks - Displays the tasks runnable from root project ‘learn’. java 插件taskBuild tasksassemble - Assembles the outputs of this project. [jar]build - Assembles and tests this project. [assemble, check]buildDependents - Assembles and tests this project and all projects that depend on it. [build]buildNeeded - Assembles and tests this project and all projects it depends on. [build]classes - Assembles main classes. compileJava - Compiles main Java source. processResources - Processes main resources.clean - Deletes the build directory.jar - Assembles a jar archive containing the main classes. [classes]testClasses - Assembles test classes. [classes] compileTestJava - Compiles test Java source. processTestResources - Processes test resources. Documentation tasksjavadoc - Generates Javadoc API documentation for the main source code. [classes] Verification taskscheck - Runs all checks. [test]test - Runs the unit tests. [classes, testClasses] RulesPattern: clean: Cleans the output files of a task.Pattern: build: Assembles the artifacts of a configuration.Pattern: upload: Assembles and uploads the artifacts belonging to a configuration. springboot插件taskApplication tasksbootRun - Run the project with support for auto-detecting main class and reloading static resources [classes] findMainClassrun - Runs this project as a JVM application [classes] findMainClass Build tasksassemble - Assembles the outputs of this project. [bootRepackage, distTar, distZip, jar]bootRepackage - Repackage existing JAR and WAR archives so that they can be executed from the command line using ‘java -jar’ [distTar, distZip, jar] Distribution tasksassembleDist - Assembles the main distributions [distTar, distZip]distTar - Bundles the project as a distribution. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application.distZip - Bundles the project as a distribution. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application.installDist - Installs the project as a distribution as-is. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application. eclipse插件taskIDE taskscleanEclipse - Cleans all Eclipse files. cleanEclipseClasspath cleanEclipseJdt cleanEclipseProjecteclipse - Generates all Eclipse files. eclipseClasspath - Generates the Eclipse classpath file. eclipseJdt - Generates the Eclipse JDT settings file. eclipseProject - Generates the Eclipse project file. 生命周期之间的执行顺序test - Runs the unit tests. [classes, testClasses]中括号是他的前一阶段，执行他就会先执行前面的task，依次类推，就会找到他的执行顺序。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学用gradle搭建springboot项目]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%88%9D%E5%AD%A6gradle%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[安装gradle插件安装完成后，在开发工具中新建一个gradle项目;项目位置 编辑配置文件build.gradle作用相当于maven的pom123456789101112131415161718192021222324252627282930313233343536373839404142434445/*依赖的插件*/apply plugin: &apos;java&apos;apply plugin: &apos;eclipse&apos;apply plugin: &apos;spring-boot&apos;/*jdk版本*/sourceCompatibility = 1.8/*打包配置*/version = &apos;1.0&apos;jar &#123; manifest &#123; attributes &apos;Implementation-Title&apos;: &apos;Gradle Quickstart&apos;, &apos;Implementation-Version&apos;: version &#125;&#125;/*第三方库来源*/repositories &#123; mavenCentral()&#125;/*gradle 自身需要的依赖放在这里面，插件 就需要放在这里面*/buildscript &#123; ext &#123; springBootVersion = &quot;1.2.3.RELEASE&quot;&#125; repositories &#123; jcenter() /*是一个插件仓库，导入的插件将会在仓库中寻找并下载*/ &#125; dependencies &#123; /*必须配置，不然没法用springboot插件，脚本自身用的依赖都放到这里*/ classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;/*声明依赖*/dependencies &#123;/*这里是项目需要的依赖，也是有依赖范围的*/ compile &apos;org.springframework.boot:spring-boot:1.5.4.RELEASE&apos; compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.4.RELEASE&quot;) compile &apos;org.springframework.boot:spring-boot-autoconfigure:1.5.4.RELEASE&apos;&#125; spring-boot-gradle-plugin插件的task 分别用于打包和启动 task讲解1234567891011121314151617181920212223242526/*自定义的task，后面自定义构建玩一下，相当于maven里面的插件goal*/task testtask &#123; println &apos;哈哈哈哈&apos; /*每个task都有着两个方法*/ doLast &#123; println &apos;last&apos;&#125; doFirst &#123; println &apos;first&apos;&#125;&#125;/*task之间的依赖*/task testtask1(dependsOn:testtask) &#123; println &apos;哈哈哈哈1&apos;&#125;/* 覆盖java插件内置的task*/clean &#123;println &apos;测试clean，覆盖默认&apos;&#125;/*为task加组别和描述*/task addTask(group:&apos;测试组&apos;,description:&apos;task的描述&apos;)&#123;&#125; 查看task 命令查看所有的taks gradle -q tasks 查看所有的taks，一缩进方式显示依赖 gradle -q tasks –all gradle 执行顺序1.初始化阶段，会去读取根工程中setting.gradle中的include信息，决定有哪几个工程加入构建， 创建project实例，比如下面有三个工程： include ‘:app’, ‘:lib1’, ‘:lib2 2.配置阶段，会去执行所有工程的build.gradle脚本，配置project对象，一个对象由多个任务组成， 此阶段也会去创建、配置task及相关信息。 3.运行阶段，根据gradle命令传递过来的task名称，执行相关依赖任务 gradle task 命令执行任何一个task或者后面没有task，此时执行默认task，都会经历1 2 步骤，最后才执行相应的task中的action]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linu进程端口资源常用命令整理]]></title>
    <url>%2F2018%2F01%2F06%2Flinu%E8%BF%9B%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%B5%84%E6%BA%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程常用命令查看进程ps 查看所有进程 常用参数 ps aux ，ps -le-a 显示一个终端的所有进程，除了会话引线-u 显示进程的归属用户和内存适用情况-x 显示没有控制终端的进程-l 显示更加详细的信息-e 显示所有进程结果字段意思USER 所属用户PID 进程的唯一id%CPU 消耗cpu的百分比%MEM 消耗内存的百分比STAT 进程状态 START 运行开始时间TIME 占用cpu总时间 执行的命令VSZ(占用的虚拟内存) 单位都是kbRSS（占用的真是内存） 单位都是kbTTY，该进程是在那个终端中运行的。TTY1-TTY7是本地终端，TTY1-TTY6是字符界面终端，TTY7是图形界面终端，TTY/0-255是远程终端 常用 ps -ef | grep 程序名 选项含义如下：ps:将某个进程显示出来-A 显示所有程序。-e 此参数的效果和指定”A”参数相同。-f 显示UID,PPIP,C与STIME栏位。grep命令是查找中间的|是管道命令 是指ps命令与grep同时执行 字段含义如下UID PID PPID C STIME TTY TIME CMD各相关信息的意义：UID 程序被该 UID 所拥有PPID 则是其上级父程序的IDC CPU 使用的资源百分比STIME 系统启动时间 查看进程树pstree 显示进程树，以父子进程的关系显示，查看统一个服务有启动了几个进程特别方便-u 显示所属用户-p 显示pid 杀死进程杀死一个进程 kill -9 pid杀死一组进程 killall 进程名 端口查看命令netstat 查看端口是否开放-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命 telnet 探测端口是否可以访问到telnet ip port 查看系统资源查看内存适用情况free -[b|k|m|g] 查看硬盘使用情况df -[b|k|m]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux操作文件]]></title>
    <url>%2F2018%2F01%2F04%2Flinux%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[编辑文件创建文件 vim 文件名编辑文件 vim 文件名编辑文件，输入 i 切换到插入模式保存文件 按esc切换到命令模式:wq 保存并退出 #查看文件ls 查看文件列表 （ll 就是 ls -l的别名）find 用来查找文件 删除文件夹rm -rf /var/log/httpd/access将会删除/var/log/httpd/access目录以及其下所有文件、文件夹 删除文件rm -f /var/log/httpd/access.log将会强制删除/var/log/httpd/access.log这个文件 复制文件[root@localhost share]# mkdir /usr/java/ // 在/usr目录下新建一个java目录[root@localhost share]# cp jdk-6u45-linux-i586.bin /usr/java/ // 将JDK文件复制 解压文件tar 命令-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 总结linux操作文件next主题的相关设置]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo初体验]]></title>
    <url>%2F2018%2F01%2F04%2Fhexo%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[要注意的问题，:后面需要一个空格端口占用情况markDown语法 文件修改后，执行下面两个命令相当于刷新$ hexo clean$ hexo s -g 链接示例 第二部分1234代码示例public static String getName() &#123; System.out.println(&quot;代码符号在左上角esc键下面！！！&quot;)&#125; 引用 狂人日记 粗体 无序列表 无序列表项1 无序列表项2 无序列表项3 有序列表写法：1.有序列表项12.有序列表项23.有序列表项3 测试a标签 红色测试 表格 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 og bird cat foo foo foo bar bar bar baz baz baz 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
