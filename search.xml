<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot单元测试和集成测试]]></title>
    <url>%2F2018%2F04%2F06%2Fspringboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[初学springboot单元测试和继承测试项目位置 单元测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Slf4j@SpringBootTest/*@Rollback(value = false)@Transactional@EnableTransactionManagement*/public class UserControlTests &#123; private IUserService userService; private UserDo userDo; @BeforeClass //只执行一次 public void setUp() &#123; log.info(&quot;beforClass&quot;); &#125; @BeforeMethod //每次测试方法执行前运行 public void before() throws Exception&#123; log.info(&quot;beforeMethod&quot;); userDo = new UserDo(); userDo.setUserName(&quot;li&quot;); userDo.setPassword(&quot;123456&quot;); userService = PowerMockito.mock(UserServiceImpl.class);//不会真正调用方法创建的对象的方法 //模拟restful 每次方法前执行 RestAssuredMockMvc.standaloneSetup(new UserControl(userService)); &#125; @After public void after() throws Exception &#123; log.info(&quot;测试结束&quot;); &#125; @Test(dataProvider = &quot;insertData&quot;) public void insertUser(Integer result, String userName, String password) throws Exception &#123; log.info(&quot;进入测试方法注册用户&quot;); UserDo userDo = new UserDo(); userDo.setPassword(password); userDo.setUserName(userName); //模拟返回数据 PowerMockito.when(userService.addUser(userDo)).thenReturn(1); // //进行测试 RestAssuredMockMvc.given() .contentType(ContentType.JSON) .body(userDo) .log() .all() .when() .post(&quot;/signUp&quot;) .then() .statusCode(200) .contentType(ContentType.JSON) .body(&quot;code&quot;,org.hamcrest.Matchers.equalTo(1000)); &#125; //构造测试数据 @DataProvider(name = &quot;insertData&quot;) public Object[][] insertData()&#123; return new Object[][] &#123; &#123;1,&quot;li&quot;,&quot;li&quot;&#125;, &#123;0,&quot;chun&quot;,&quot;chun&quot;&#125; &#125;; &#125;&#125; 继承测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@SpringBootTest@Slf4jpublic class UserControlIntegrations extends AbstractTestNGSpringContextTests &#123;//必须继承此类 @Autowired //注入上下文真实环境 private WebApplicationContext context; @BeforeClass public void setUp()&#123; //模拟http请求和web环境 RestAssuredMockMvc.webAppContextSetup(context); &#125; @Test(dataProvider = &quot;insertData&quot;) public void testSignUp(String expected ,String userName, String password)&#123; UserDo userDo = new UserDo(); userDo.setPassword(password); userDo.setUserName(userName); RestAssuredMockMvc.given() .contentType(ContentType.JSON) .body(userDo) .log() .all() .when() .post(&quot;/signUp&quot;) .then() .statusCode(200) .contentType(ContentType.JSON); &#125; @Test(dataProvider = &quot;insertData&quot;, dependsOnMethods = &quot;testSignUp&quot;) public void testLogin(String expected ,String userName, String password)&#123; UserDo userDo = new UserDo(); userDo.setPassword(password); userDo.setUserName(userName); RestAssuredMockMvc.given() .contentType(ContentType.JSON) .body(userDo) .log() .all() .when() .post(&quot;/login&quot;) .then() .statusCode(200) .contentType(ContentType.JSON); &#125; @DataProvider(name = &quot;insertData&quot;) public Object[][] insertData()&#123; return new Object[][] &#123; &#123;&quot;成功&quot;,&quot;li&quot;,&quot;li&quot;&#125;, &#123;&quot;失败&quot;,&quot;chun&quot;,&quot;chun&quot;&#125; &#125;; &#125;&#125; 总结单元测试 1只是仅仅模拟数据，不会调用数据库，mock创建的对象都不会真正执行 2用PowerMockito 创建对象和模拟返回的数据 集成测试 1真实模拟环境 2会真正执行所有操作，包括数据库操作 3dependsOnMethods 的作用 集成测试和单元测试区别单元测试如何实现数据库操作]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连接池]]></title>
    <url>%2F2018%2F02%2F25%2F%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[常见的连接池1 Tomcat的数据库链接池2 HikariCP链接池3 Commons DBCP，但Spring Boot不建议在生产环境使用该链接池的实现。不稳定Commons DBCP24 C3P0 Spring的数据源实现类Spring本身也提供了一个简单的数据源实现类DriverManagerDataSource，它位于org.springframework.jdbc.datasource包中。这个类实现了javax.sql.DataSource接口，但它并没有提供池化连接的机制，每次调用getConnection()获取新连接时，只是简单地创建一个新的连接。因此，这个数据源类比较适合在单元测试或简单的独立应用中使用，因为它不需要额外的依赖类。 com.alibaba.druid.pool.DruidDataSource1 构造方法 通过System.getProperties()获取连接配置属性，属性名都是以druid.开头，2 获取连接，如果池中数量为0，则创建创建连接事件并提交，由相应的执行器去完成任务。。。3 从池中获取一个连接，是否需要检查连接。。。返回连接]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot总结]]></title>
    <url>%2F2018%2F02%2F24%2Fspringboot%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[配置的使用@SpringBootApplication启动类加注解开启springboot自动配置和扫描相当于@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个注解当放置在根包下时，不需要配置扫描包 配置类@Configuration @Import(**.class) //次注解可以将一个类注入bean，本身不需要@Configuration 配置bean (@Configuration或者 @Component)@ConfigurationProperties 和 @Configuration或者 @Component 搭配一起使用 一个类上加注解@ConfigurationProperties,另一个类上加@EnableConfigurationProperties 配置属性@ConfigurationProperties(prefix = “spring.datasource”) //需要setter方法 @Value(“${spring.datasource.driverClassName}”) //不需要setter方法 private String driverClassName; @Configuration@PropertySource(“classpath:app.properties”)//加入到Environment,如果存在相同的key,则会被application（默认加载的env中）中的value覆盖public class EnvironmentTest { }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基本概念]]></title>
    <url>%2F2018%2F02%2F18%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[时间复杂度和空间复杂度 时间复杂度是指执行算法所需要的计算工作量。 计算方法1.一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。分析：随着模块n的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，所以 f(n) 越小，算法的时间复杂度越低，算法的效率越高。 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log2n，n，n log2n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n)) 空间复杂度是指执行这个算法所需要的内存空间。一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。 若一个算法为递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F02%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树二叉树定义二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点：1.每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。没有子树或者有一棵子树是可以的，最多有两棵子树。2.左子树和右子树是有顺序的，次序不能颠倒。3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。二叉树具有五种基本形态：1.空二叉树；2.只有一个根结点；3.根结点只有左子树；4.根结点只有右子树；5.根结点既有左子树又有右子树。 二叉树的性质性质一：在二叉树的第i层上至多有 2i−1 个结点（i≥1）。—–归纳法性质二：深度为k的二叉树至多有 2k−1 个结点（k≥1）。—–归纳法性质三：对任何一棵二叉树T，如果其终端结点数为 n0，度为2的结点数为 n2，则 n0=n2+1。设 n1 为度是1的结点数，那么T结点总数 n=n0+n1+n2 。换个角度，数数连接连线，因为根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1，分支线总数为 n−1=n1+2n2 ，两个式子相减得到 n0=n2+1。性质四：具有n个结点的完全二叉树的深度为 |log2n|+1（其中|x|表示不大于x的最大整数）。性质五：如果对一棵有n个结点的完全二叉树（深度为 |log2n|+1）的结点按层序编号（从第1层到第 |log2n|+1层，每层从左到右），对任一结点i（1≤i≤n）有：1.如果 i=1，则结点i是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点|i/2|。2.如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。3.如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。 二叉树顺序存储结构二叉树比较特殊，所以可以使用顺序存储结构可以实现。二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，例如双亲与孩子的关系，左右兄弟的关系等等。完全二叉树的存储可以根据结点的编号来存储，一般的二叉树，尽管层序编号不能反映逻辑关系，但是可按完全二叉树编号，将不存在的结点设置为“∧”。若是考虑极端情况，例如右斜树，k个结点，却分配 2k−1 个存储单元空间，浪费了存储空间。所以，顺序存储结构一般只用于完全二叉树。 二叉树的建立建立二叉树，其实也利用了递归的原理，只不过在打印结点的地方，改成生成结点、给结点赋值的操作。当然也可以用中序或后续遍历的方式实现二叉树的建立，只是结点生成和左右子树的构造顺序需要交换一下，另外，输入的字符也要相应的变化。 基本方法及源码12 特殊二叉树斜树所有的结点都只有左子树的二叉树叫左斜树。所有的结点都是只有右子树的二叉树叫右斜树。这二者统称为斜树。斜树有明显特点，每一层都只有一个结点，结点的个数和二叉树的深度相同。斜树和线性表结构一样，线性表结构是树的一种特殊表现形式。 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。单是每个节点都存在左右子树，不能算是满n二叉树，还必须要所有的叶子结点都在同一层上，这样就做到了整棵树的平衡。所以，满二叉树的特点是：1.叶子只能出现在最下一层，出现在其他层就不能达到平衡；2.非叶子结点的度一定是2；3.在同样深度的二叉树中，满二叉树的结点最多，叶子数最多。 完全二叉树对一棵具有n个结点的二叉树 按层序编号 ，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。完全二叉树的特性：（1）叶子结点只能出现在最下两层。（2）最下层的叶子一定集中在左部连续位置。（3）倒数第二层，若有叶子结点，一定都在右部连续位置。（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。（5）同样结点数的二叉树，完全二叉树的深度最小。 二叉链表二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，称这样的链表叫做二叉链表。下面列出二叉链表的结点结构定义代码：/二叉树的二叉链表结点结构定义/typedef struct BitNode{ //结点结构 TElemType data; //结点数据 struct BiTNode lchild,rchild; //左右孩子指针}BitNode，*BiTree；]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数组、链表、队列、栈]]></title>
    <url>%2F2018%2F02%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%A0%88%2F</url>
    <content type="text"><![CDATA[数组定义同类数据元素的集合 特点1.数组是相同数据类型的元素的集合2.数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起3.数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。4.元素在内存中线性连续存储，可以根据下标快速访问数组元素，但是增删效率不是很高，每一次增加或删除元素都需要大量移动元素空出插入位置或者填补删除元素的位置。 使用场景频繁查询，很少进行增加或删除操作的情况数组的长度是固定，一旦创建，不能更改 创建数组1234Map&lt;String,Object&gt;[] maps = new HashMap[10]; int[] a2 = new int[10];int[] a = &#123;1,2&#125;; 链表定义是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 特点存储可以不连贯，根据索引将数据联系起来，当查询元素的时候需要从开头开始去查询，所以效率比较低 使用场景少查询，需要频繁插入或删除的情况 基本操作 增、删、改、查、反序源码数组与链表的区别(1)数组连续，链表不连续(2)数组内存静态分配，链表内存动态分配(3)数组查询时间复杂度为O(1),链表为0(n)(4)数组增加删除的时间复杂度为O(n),链表为O(1)(5)数组从栈中分配空间，链表从堆中分配空间 Stack 栈定义栈是限定仅在表头（栈顶）进行插入和删除操作的线性表。 特点后进先出（last in first out，LIFO）的堆栈 使用场景：实现递归以及表达式计算 主要方法及源码E push(E item) 把项压入堆栈顶部。E pop() 移除堆栈顶部的对象，并作为此函数的值返回该对象。E peek() 查看堆栈顶部的对象，但不从堆栈中移除它。boolean empty() 测试堆栈是否为空。int search(Object o) 返回对象在堆栈中的位置，以 1 为基数。Stack本身通过扩展Vector而来，而Vector本身是一个可增长的对象数组（ a growable array of objects）那么这个数组的最大下标作为Stack的栈顶，最小下标作为Stack的栈底12 队列 FIFO 先进先出定义队列是一种只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作的特殊的线性表。和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 特征每次在队尾插入一个元素是，rear增1；每次在队头删除一个元素时，front增1。随着插入和删除操作的进行，队列元素的个数不断变化，队列所占的存储空间也在为队列结构所分配的连续空间中移动。当front=rear时，队列中没有任何元素，称为空队列。当rear增加到指向分配的连续空间之外时，队列无法再插入新元素，但这时往往还有大量可用空间未被占用，这些空间是已经出队的队列元素曾经占用过得存储单元。 使用场景如同一个单向隧道，先进的车先出，多线程的阻塞队列管理非常有用 基本操作及源码]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Content-Type]]></title>
    <url>%2F2018%2F01%2F27%2FContent-Type%2F</url>
    <content type="text"><![CDATA[Content-TypeMediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 类型格式：type/subtype(;parameter)? type主类型,如text，如果是号代表所有；subtype 子类型,如html，如果是号代表所有；parameter 可选，一些参数，如Accept请求头的q参数,Content-Type的 charset参数。例如： Content-Type: text/html;charset:utf-8; 常见的媒体格式类型如下：• text/html ： HTML格式• text/plain ：纯文本格式• text/xml ： XML格式• image/gif ：gif图片格式• image/jpeg ：jpg图片格式• image/png：png图片格式 以application开头的媒体格式类型：• application/xhtml+xml ：XHTML格式• application/xml ： XML数据格式• application/atom+xml ：Atom XML聚合格式• application/json ： JSON数据格式• application/pdf ：pdf格式• application/msword ： Word文档格式• application/octet-stream ： 二进制流数据（如常见的文件下载）• application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的：• multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。 Spring MVC中关于关于Content-Type类型信息的使用首先我们来看看RequestMapping中的Class定义：123456789101112@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @Mapping public @interface RequestMapping &#123; String[] value() default &#123;&#125;; RequestMethod[] method() default &#123;&#125;; String[] params() default &#123;&#125;; String[] headers() default &#123;&#125;; String[] consumes() default &#123;&#125;; String[] produces() default &#123;&#125;; &#125; value: 指定请求的实际地址， 比如 /action/info之类。method： 指定请求的method类型， GET、POST、PUT、DELETE等consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回params： 指定request中必须包含某些参数值是，才让该方法处理headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求其中，consumes， produces使用content-typ信息进行过滤信息；headers中可以使用content-type进行过滤和判断。 Content-disposition(一般文件下载时候用)是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。（请注意，这是设计导致的；无法使用此功能将文档保存到用户的计算机上，而不向用户询问保存位置。）Content-Disposition就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名。具体的定义 那么由上可知具体的例子：Content-Disposition: attachment; filename=“filename.xls”当然filename参数可以包含路径信息，但User-Agnet会忽略掉这些信息，只会把路径信息的最后一部分做为文件名。当你在响应类型为application/octet- stream情况下使用了这个头信息的话，那就意味着你不想直接显示内容，而是弹出一个”文件下载”的对话框，接下来就是由你来决定“打开”还是“保存”了。如:Response.AppendHeader(“Content-Disposition”,”attachment;filename=MyExcel.xls”);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>content-type</tag>
        <tag>header</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成二维码]]></title>
    <url>%2F2018%2F01%2F20%2F%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[近来客户资料需要归档，用二维码来存储一些信息，为此特学习了二维码如何生成。 1. 需要的依赖如下12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; 2. 二维码示例可以加logo，也可以画上一些文字 3. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.Image;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import java.util.UUID;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.WriterException;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import com.google.zxing.qrcode.encoder.ByteMatrix;import com.google.zxing.qrcode.encoder.Encoder;import com.google.zxing.qrcode.encoder.QRCode;public class QrCode &#123; static final int BLACK = 0xFF000000; static final int WHITE = 0xFFFFFFFF; static final int QUIET_ZONE_SIZE = 4;// 边框大小参数 public static void main(String[] args) throws IOException, WriterException &#123; String text = &quot;C:\\springboot-tomcat-tmp\\upload\\QRCode\\20180119&quot;; writeToStreamEntire(text, 500, 500, &quot;&quot;, &quot;&quot;, null); &#125; public static void writeToStreamEntire(String text, int width, int height, String format, String newPath, Object o) throws IOException, WriterException &#123; String p = &quot;C:\\springboot-tomcat-tmp\\upload\\QRCode\\20180119&quot;; //图片生成后的路径 newPath = p + File.separator + UUID.randomUUID() + &quot;.jpg&quot;; //预设置二维码大小 非实际值 width = 200; height = 200; System.out.println(&quot;writeToStreamEntire 入参: &quot; + &quot;text : &quot; + text + &quot; ,width=&quot; + width + &quot;,height=&quot; + height + &quot; ,format=&quot; + format + &quot;,newPath=&quot; + newPath); Hashtable&lt;EncodeHintType, String&gt; hints = new Hashtable&lt;EncodeHintType, String&gt;(); hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;); // 内容所使用字符集编码 hints.put(EncodeHintType.ERROR_CORRECTION, &quot;Q&quot;);// 容错率 共四种级别 BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints); // 用户获取偏移 二维码 空白部分的偏移 Map&lt;String, Integer&gt; xy = getXY(text, BarcodeFormat.QR_CODE, width, height, hints); // 二维码实际大小 包括边框 int widthR = bitMatrix.getWidth(); int heightR = bitMatrix.getHeight(); // 图片实际像素大小 实际的大小不能小于 二维码输出的大小 否则 扫不出来 int outHight = heightR + 500; int outWidth = widthR + 500; BufferedImage image = new BufferedImage(outWidth, outHight, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; outWidth; x++) &#123; for (int y = 0; y &lt; outHight; y++) &#123; if (x &lt; widthR &amp;&amp; y &lt; heightR) &#123; image.setRGB(x, y, bitMatrix.get(x, y) ? BLACK : WHITE); &#125; else &#123; image.setRGB(x, y, WHITE); &#125; &#125; &#125; FileOutputStream stream = null; // 中间加 个人图片 Graphics2D gs = image.createGraphics(); int ratioWidth = widthR * 2 / 10; int ratioHeight = heightR * 2 / 10; // 载入logo String logoPath = &quot;C:\\Users\\lixia\\Desktop\\java\\毕业季\\me.jpg&quot;; Image img = ImageIO.read(new File(logoPath)); int logoWidth = img.getWidth(null) &gt; ratioWidth ? ratioWidth : img.getWidth(null); int logoHeight = img.getHeight(null) &gt; ratioHeight ? ratioHeight : img.getHeight(null); int x = (widthR - logoWidth) / 2; int y = (heightR - logoHeight) / 2; gs.drawImage(img, x, y, logoWidth, logoHeight, null); gs.setColor(Color.black); gs.setBackground(Color.WHITE); gs.dispose(); img.flush(); try &#123; stream = new FileOutputStream(newPath); if (!ImageIO.write(image, &quot;jpg&quot;, stream)) &#123; throw new IOException(&quot;Could not write an image of format &quot; + format); &#125; // stream.write(&quot;四大地方地方&quot;.getBytes()); &#125; finally &#123; if (stream != null) &#123; stream.close(); &#125; &#125; try &#123; // 读取原图片信息 File srcImgFile = new File(newPath); Image srcImg = ImageIO.read(srcImgFile); int srcImgWidth = srcImg.getWidth(null); int srcImgHeight = srcImg.getHeight(null); // 加水印 加工生成的图片 BufferedImage bufImg = new BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = bufImg.createGraphics(); // 将生成的图片 读取出来 花在新的 图片对象上 若宽和高于图片本身不一致，则进行缩放 画到新的图片对象中 g.drawImage(srcImg, 0, 0, widthR, heightR, null); // 设置字体大小 // 根据最小字体大小设置 int min = widthR &gt; heightR ? heightR : widthR; int fontSize = (heightR - xy.get(&quot;Y&quot;) * 2) / 6; Font font = new Font(&quot;宋体&quot;, Font.PLAIN, fontSize - fontSize * 2 / 10); g.setColor(Color.white); // 根据图片的背景设置水印颜色 g.setFont(font); // 设置右边偏移 int rightX = widthR + widthR * 2 / 10; int rightY = xy.get(&quot;Y&quot;) + fontSize - fontSize * 2 / 10; g.drawString(&quot;客户姓名：&quot; + &quot;李显春&quot;, rightX, rightY); g.drawString(&quot;业务类型：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 1); g.drawString(&quot;品牌：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 2); g.drawString(&quot;车牌号：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 3); g.drawString(&quot;管理类型：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 4); g.drawString(&quot;档案管理：&quot; + &quot;李显春&quot;, rightX, rightY + fontSize * 5); // 设置下边偏移 int downX = xy.get(&quot;X&quot;); int downY = heightR + heightR * 2 / 10; g.drawString(&quot;档案编号：&quot; + &quot;李显春&quot;, downX, downY); g.drawString(&quot;合同号：&quot; + &quot;CPHZ20170504N000007&quot;, downX, downY + fontSize * 1); g.drawString(&quot;车架号：&quot; + &quot;HT20170408CG0004&quot;, downX, downY + fontSize * 2); g.drawString(&quot;资料清单：&quot; + &quot;归档资料（售后回租个人）&quot;, downX, downY + fontSize * 3); g.drawString(&quot;经销商名称：&quot; + &quot;woshi&quot;, downX, downY + fontSize * 4); g.dispose(); // 输出图片 FileOutputStream outImgStream = new FileOutputStream(newPath); ImageIO.write(bufImg, &quot;jpg&quot;, outImgStream); outImgStream.flush(); outImgStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 获取偏移 public static Map&lt;String, Integer&gt; getXY(String contents, BarcodeFormat format, int width, int height, Map&lt;EncodeHintType, ?&gt; hints) throws WriterException &#123; if (contents.isEmpty()) &#123; throw new IllegalArgumentException(&quot;Found empty contents&quot;); &#125; if (format != BarcodeFormat.QR_CODE) &#123; throw new IllegalArgumentException(&quot;Can only encode QR_CODE, but got &quot; + format); &#125; if (width &lt; 0 || height &lt; 0) &#123; throw new IllegalArgumentException(&quot;Requested dimensions are too small: &quot; + width + &apos;x&apos; + height); &#125; ErrorCorrectionLevel errorCorrectionLevel = ErrorCorrectionLevel.L; int quietZone = QUIET_ZONE_SIZE; if (hints != null) &#123; if (hints.containsKey(EncodeHintType.ERROR_CORRECTION)) &#123; errorCorrectionLevel = ErrorCorrectionLevel .valueOf(hints.get(EncodeHintType.ERROR_CORRECTION).toString()); &#125; if (hints.containsKey(EncodeHintType.MARGIN)) &#123; quietZone = Integer.parseInt(hints.get(EncodeHintType.MARGIN).toString()); &#125; &#125; QRCode code = Encoder.encode(contents, errorCorrectionLevel, hints); ByteMatrix input = code.getMatrix(); if (input == null) &#123; throw new IllegalStateException(); &#125; int inputWidth = input.getWidth(); int inputHeight = input.getHeight(); int qrWidth = inputWidth + (quietZone * 2); int qrHeight = inputHeight + (quietZone * 2); int outputWidth = Math.max(width, qrWidth); int outputHeight = Math.max(height, qrHeight); int multiple = Math.min(outputWidth / qrWidth, outputHeight / qrHeight); int leftPadding = (outputWidth - (inputWidth * multiple)) / 2; int topPadding = (outputHeight - (inputHeight * multiple)) / 2; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;X&quot;, leftPadding); map.put(&quot;Y&quot;, topPadding); return map; &#125;&#125; 4. 注意与总结 1 理论上来讲，二维码是限的，就从图片上的点数也可以发现，不过数量应该巨大，还不知道是如何编码解析的。 2 生成的二维码大小和边框是自动计算的，不能手动设置。 3 二维码是有容错率的，即使部分丢失，也是可以扫出来的，因为编码有冗余。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle sql 总结]]></title>
    <url>%2F2018%2F01%2F11%2Foracle%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[oracle 常用查询– 子查询 ,在个别字段需要特殊处理的时候，这种子查询用起来特别好 select a.*, (select max(b.request_attachment_id) from tlb_request_to_attachment b where b.p_attachment_id = a.attachment_id) from tc_attachment a – decode 与 case when – 可以用在 三表关联– 可以看成都是对值进行编码,都只是单列处理,不同的是，case when 可以跟子查询，而decode 不能 ，因为decode 是函数 SELECT A.* ,DECODE (A.TLB_TYPE ,’1’,B.NAME ,’2’,C.NAME,NULL) FROM TLB_CARS_LIST_DETAIL ALEFT JOIN TLB_REQUEST_PERSONAL B ON A.TLB_ID = B.TLB_IDLEFT JOIN TLB_REQUEST_BIG_CUSTOMER C ON A.TLB_ID = C.TLB_ID SELECT CASE UNION_ID WHEN ‘700’ THEN ‘1’ WHEN ‘710’ THEN (SELECT PERSON_ID FROM TB_CFS_AUDITGROUP_PERSON_UNION U WHERE U.UNION_ID = A.UNION_ID ) ELSE ‘3’ END FROM TB_CFS_AUDITGROUP_PERSON_UNION A 修正 decode 后面可以跟子查询，不过要求结果是单条记录 SELECT A.* ,DECODE ((SELECT TLB_TYPE FROM TLB_CARS_LIST_DETAIL WHERE CAR_LIST_ID = A.CAR_LIST_ID) ,’1’,B.USER_NAME ,’2’,C.NAME,NULL) FROM TLB_CARS_LIST_DETAIL ALEFT JOIN TLB_REQUEST_PERSONAL B ON A.TLB_ID = B.TLB_IDLEFT JOIN TLB_REQUEST_BIG_CUSTOMER C ON A.TLB_ID = C.TLB_ID – 两表关联查询 存在不存在SELECT A.*,CASE when B.PERSON_ID IS NULL THEN ‘0’ ELSE ‘1’ END IS_IN FROM TB_CFS_AUDIT_GROUP_PERSON A LEFT JOIN TB_CFS_AUDITGROUP_PERSON_UNION B ON ( A.PERSON_ID=B.PERSON_IDAND GROUP_ID =211 ) SELECT A.*,CASE when A.PERSON_ID = ANY (SELECT PERSON_ID FROM TB_CFS_AUDITGROUP_PERSON_UNION U WHERE U.GROUP_ID =B.GROUP_ID ) THEN ‘0’ ELSE ‘1’ END IS_IN FROM TB_CFS_AUDIT_GROUP_PERSON A LEFT JOIN TB_CFS_AUDITGROUP_PERSON_UNION B ON ( A.PERSON_ID=B.PERSON_IDAND GROUP_ID =211 ) – 自连接 去重 或是 exist– 查找只有单条记录无对应的下一步记录，第二种是自连接实现的剔除，有点low select * from tba_agent_bail_detail a where not exists (select 1 from tba_agent_bail_detail where a.business_id = business_id and a.business_type = business_type and a.bail_detail_id != bail_detail_id and a.bail_type = bail_type and a.bail_amount = bail_amount) and a.bail_type in (‘3’, ‘4’) and a.bail_flag = ‘1’ and business_type in (‘TLB_REQUEST_PERSONAL’, ‘TLB_REQUEST_BIG_CUSTOMER’); select * from (select a.bail_detail_id, a.business_type, a.business_id, a.bail_type, a.bail_flag, a.bail_amount, a.agent_id, a.remark, to_char(a.create_date, ‘yyyy-mm-dd’) create_date, (case when a.bail_type = 3 then b.GPS_DEPOSIT_LEVERAGE else b.ACCESS_DEPOSIT_LEVERAGE end) AS “DEPOSIT_LEVERAGE”, c.agent_name, d.user_name, d.tlb_code, d.contract_number, to_char(d.apply_final_time, ‘yyyy-mm-dd’) apply_final_time, to_char(d.apply_down_time, ‘yyyy-mm-dd’) apply_down_time, d.vehicle_category, d.APPLY_STATUES from tba_agent_bail_detail a left join tba_agent_bail b on b.agent_id = a.agent_id left join tdl_agent_apply c on c.agent_id = a.agent_id left join TLB_REQUEST_PERSONAL d on d.tlb_id = a.business_id where a.business_type = ‘TLB_REQUEST_PERSONAL’ and a.bail_flag in (‘1’, ‘2’) union all select a.bail_detail_id, a.business_type, a.business_id, a.bail_type, a.bail_flag, a.bail_amount, a.agent_id, a.remark, to_char(a.create_date, ‘yyyy-mm-dd’) create_date, (case when a.bail_type = 3 then b.GPS_DEPOSIT_LEVERAGE else b.ACCESS_DEPOSIT_LEVERAGE end) as “DEPOSIT_LEVERAGE”, c.agent_name, d.name as user_name, d.tlb_code, d.contract_number, to_char(d.apply_final_time, ‘yyyy-mm-dd’) apply_final_time, to_char(d.apply_down_time, ‘yyyy-mm-dd’) apply_down_time, d.vehicle_category, d.APPLY_STATUES from tba_agent_bail_detail a left join tba_agent_bail b on b.agent_id = a.agent_id left join tdl_agent_apply c on c.agent_id = a.agent_id left join TLB_REQUEST_BIG_CUSTOMER d on d.tlb_id = a.business_id where a.business_type = ‘TLB_REQUEST_BIG_CUSTOMER’ and a.bail_flag in (‘1’, ‘2’)) t where to_number(trim(t.APPLY_STATUES)) &gt;= 419 AND bail_detail_id NOT IN (SELECT A.BAIL_DETAIL_ID FROM TBA_AGENT_BAIL_DETAIL A JOIN TBA_AGENT_BAIL_DETAIL B ON A.BUSINESS_ID = B.BUSINESS_ID AND A.BUSINESS_TYPE = B.BUSINESS_TYPE AND A.BAIL_TYPE = B.BAIL_TYPE AND A.BAIL_AMOUNT = B.BAIL_AMOUNT AND A.BAIL_DETAIL_ID &lt;&gt; B.BAIL_DETAIL_ID AND A.BAIL_FLAG = ‘1’) AND AGENT_ID = 1533 AND BAIL_FLAG = ‘1’ order by business_type, to_number(business_id), bail_flag, bail_amount – 树 – 查询父节点 根据子节点查找父节点select *from tb_value_list_detailsstart with ( details_id = ‘1361’ )connect by prior p_father_id= details_id – 查询子节点 根据父节点查找子节点 select *from tb_value_list_detailsstart with ( details_id = ‘1361’ )connect by p_father_id= prior details_id – 拼接字符串 成为一列类似于行转列 ,两个函数都有字符数限制,但listagg还可以实现排序 拼接SELECT REPLACE(listagg(TAG_NAME, ‘,’) within group(order by to_number(tag_up_id)), ‘,’, ‘&gt;’) AS TAG_NAME FROM TCM_TAG a where tag_level &gt; 1 START WITH TAG_ID = ‘52’ CONNECT BY PRIOR TAG_UP_ID = TAG_ID SELECT REPLACE(wm_concat(TAG_NAME) ‘,’, ‘&gt;’) AS TAG_NAMEFROM TCM_TAG awhere tag_level &gt; 1START WITH TAG_ID = ‘52’CONNECT BY PRIOR TAG_UP_ID = TAG_ID –查询被锁对象和解锁select object_name,machine,s.sid,s.serial#,L.OS_USER_NAMEfrom v$locked_object l,dba_objects o ,v$session swhere l.object_id = o.object_id and l.session_id=s.sid; 解锁alter system kill session ‘sid,serial#’ – 动态sql拼接，就是相当于单引号内 两个单引号表示一个单引号1 字符串拼接declarev_count number default 0;v_id varchar(36);v_sql varchar(1000);begin dbms_output.put_line(‘测试 sql in 不能接受多值的情况’);v_id :=’’’7797’’,’’1109’’’;v_id :=’’’7797’’,’’10000’’’;dbms_output.put_line(‘v_id: ‘||v_id);v_sql :=’ select count(1) from tc_attachment where attachment_id in (‘||v_id||’)’;execute immediate v_sql into v_count/ using v_id/; –dbms_output.put_line(‘v_count: ‘||v_count||’—-‘||v_sql); end; 2 函数实现使用 ASCII 编码，单引号 ‘ 的编码是39，所以拼接字符串可以这样写str := ‘select * from user where name=’||chr(39)||zhangsan||chr(39)||’ order by id’; oracle in 查询需要注意 – 存在select 1 from dual where 1 in (1,null) – 不存在 ,查询结果为空select 1 from dual where 1 not in (2,null) 函数1 – 为空时设置默认值 select nvl(‘ddd’,11) from dual 2 – 为值编码或转义 select decode(1,2,22) from dual 3 – 统计 count4 – 求和 sum 5 – 分组 group by 6 – 字符串转换函数 to_char select to_char(sysdate,’yyyy”-“mm-dd HH24”时”:mi:ss’) from dual7 – 时间转换函数 to_date select to_date (‘2017-09-01’,’yyyy-mm-dd’) from dual 8 – 差集 从集合去掉完全一样的 minus (select from ) minus (select from ) 9 取并集 union all 10 – 去重，对比结果的所有字段 distinct 给列取别名 – oracle 不区分大小写select 33 as ee from dualselect 33 as ee from dualselect 33 “from” from dual –# Mysql 默认区分大小写，可以配置为不区分select 11 LOW from dualselect 11 low from dualselect 11 from from dual]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[task学习]]></title>
    <url>%2F2018%2F01%2F10%2FgradleTask%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[java代码写在脚本中gradle构建脚本本可以写java代码，groove语言支持java代码 java 类定义 1234567891011121314151617181920212223242526public class VersionEntity &#123; private Integer major; private Integer minor; private boolean release; @Override public String toString() &#123; return &quot;VersionEntity [major=&quot; + major + &quot;, minor=&quot; + minor + &quot;, release=&quot; + release + &quot;]&quot;; &#125; public VersionEntity(Integer major, Integer minor, boolean release) &#123; super(); this.major = major; this.minor = minor; this.release = release; &#125; public VersionEntity() &#123; super(); this.major = 2121; &#125; &#125; 定义属性文件ext.f = file(“version.properties”); java 方法定义 123456789VersionEntity GenerateVersion() throws FileNotFoundException, IOException&#123; Properties properties = new Properties(); properties.load(new FileInputStream(f)); return new VersionEntity(Integer.valueOf(properties.get(&quot;major&quot;).toString()),Integer.valueOf(properties.get(&quot;minor&quot;).toString()), properties.getProperty(&quot;release&quot;).toString().equals(&quot;false&quot;));&#125; 调用project的task方法创建继承于defaultTask的task 1234567891011121314151617task ver &#123; /*直接调用java方法*/ project.version = GenerateVersion() version.release = true /*配置代码块中定义 输入 输出，定义的task便能执行增量式构建*/ inputs.property(&apos;release&apos;,version.release) outputs.file f doLast &#123; println project.version ant.propertyfile(file: f)&#123; /*修改属性文件中的值*/ entry(key: &apos;release&apos;,type: &apos;string&apos;,operation: &apos;=&apos;,value: &apos;true&apos;) println &apos;ver执行&apos; &#125; println project.version &#125; &#125; 自定义task类自定义task 类 也可以在java代码中定义，不过需要导入相应的包，此处gradle已经提供 12345678910111213141516171819202122class myDefaultTask extends DefaultTask &#123; /* 使用注解标识 输入 输出*/ @Input String pi @OutputDirectory po myDefaultTask ()&#123; group = &apos;定义task&apos; description = &apos;定义task,封装实现，只提供输入输出&apos; &#125; /*定义动作*/ @TaskAction void start() &#123; /*这里定义逻辑*/ println &apos;输入的是：&apos;+pi &#125;&#125; 测试增量式构建 1234567task ceShiMyDefaultTask(type: myDefaultTask)&#123; /*输入输出不变时，不在执行task*/ pi = &apos;hahhh--900&apos; po= file(&quot;/lib&quot;) doLast &#123;println &apos;ceShiMyDefaultTask&apos;&#125; &#125; 文件复制，可以参考api中Copy类这种文件复制 类似于 调用方法 123456789 task ccc()&#123; doLast&#123; copy() &#123; /* from into 都是copy对象的方法*/ from &quot;lib&quot; into &quot;test&quot; &#125; &#125;&#125; 这种文件复制 类似于继承 输入输出定义在父类中 此task执行一次就不会执行了123456789101112task hhh(type: Copy)&#123; inputs.property(&apos;release&apos;,11) outputs.dir file(&quot;111&quot;) doLast &#123; println &apos;-----------------------00000&apos; &#125; from &quot;111&quot; into &quot;2222&quot; include &quot;111.png&quot;&#125; task规则简单task只需project的task即可以添加，但是task规则只能通过taskContainer容器的addRule(String,Closure)方法 12345678910111213141516171819tasks.addRule(&apos;Pattern: Test&lt;Classifier&gt;My: 测试task规则.&apos;)&#123; String taskName -&gt; if (taskName.startsWith(&apos;Test&apos;) &amp;&amp; taskName.endsWith(&apos;My&apos;))&#123; task (taskName) &#123; doLast&#123; String classifier = taskName - &apos;Test&apos; - &apos;My&apos; switch(classifier)&#123; case &apos;1&apos; : println &apos;任务---1&apos; break case &apos;2&apos; : println &apos;任务---2&apos; break default: println &apos;任务000&apos; &#125; &#125; &#125; &#125;&#125; 编写生命周期钩子，类似于监听，事件是任务蓝图创建完成后12345678910 gradle.taskGraph.whenReady &#123;taskGraph -&gt; /*包含不一定执行动作，一定执行配置，因为有可能是最新的，*/ if(taskGraph.hasTask(&apos;:addTask&apos;)) &#123; println &apos; 存在的逻辑&apos; &#125; else &#123; println &apos; 不存在的逻辑&apos; &#125; &#125; 不依赖依赖的task，控制执行顺序1 finalizedBy就是在task执行完之后要执行的task。 2 mustRunAfter并不会添加依赖，它只是告诉Gradle执行的优先级如果两个task同时存在 总结 重点把握对生命周期、执行顺序的认识 借助gradle插件库查看源码，进行学习]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误集]]></title>
    <url>%2F2018%2F01%2F10%2F%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[常见错误处理解决The hierarchy of the type is inconsistent错误 可能的原因：自己的类继承于某个类，这个类或者这个类继承的类或者再往上继承的某个类所在的jar包没有被引入。 CallableStatementCallback; invalid ResultSet access for SQL [];参数个数错误]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学Gradle Task]]></title>
    <url>%2F2018%2F01%2F09%2Fgradle-Task%2F</url>
    <content type="text"><![CDATA[脚本默认taskBuild Setup tasksinit - Initializes a new Gradle build. [incubating]wrapper - Generates Gradle wrapper files. [incubating] Help tasksbuildEnvironment - Displays all buildscript dependencies declared in root project ‘learn’.components - Displays the components produced by root project ‘learn’. [incubating]dependencies - Displays all dependencies declared in root project ‘learn’.dependencyInsight - Displays the insight into a specific dependency in root project ‘learn’.dependentComponents - Displays the dependent components of components in root project ‘learn’. [incubating]help - Displays a help message.model - Displays the configuration model of root project ‘learn’. [incubating]projects - Displays the sub-projects of root project ‘learn’.properties - Displays the properties of root project ‘learn’.tasks - Displays the tasks runnable from root project ‘learn’. java 插件taskBuild tasksassemble - Assembles the outputs of this project. [jar]build - Assembles and tests this project. [assemble, check]buildDependents - Assembles and tests this project and all projects that depend on it. [build]buildNeeded - Assembles and tests this project and all projects it depends on. [build]classes - Assembles main classes. compileJava - Compiles main Java source. processResources - Processes main resources.clean - Deletes the build directory.jar - Assembles a jar archive containing the main classes. [classes]testClasses - Assembles test classes. [classes] compileTestJava - Compiles test Java source. processTestResources - Processes test resources. Documentation tasksjavadoc - Generates Javadoc API documentation for the main source code. [classes] Verification taskscheck - Runs all checks. [test]test - Runs the unit tests. [classes, testClasses] RulesPattern: clean: Cleans the output files of a task.Pattern: build: Assembles the artifacts of a configuration.Pattern: upload: Assembles and uploads the artifacts belonging to a configuration. springboot插件taskApplication tasksbootRun - Run the project with support for auto-detecting main class and reloading static resources [classes] findMainClassrun - Runs this project as a JVM application [classes] findMainClass Build tasksassemble - Assembles the outputs of this project. [bootRepackage, distTar, distZip, jar]bootRepackage - Repackage existing JAR and WAR archives so that they can be executed from the command line using ‘java -jar’ [distTar, distZip, jar] Distribution tasksassembleDist - Assembles the main distributions [distTar, distZip]distTar - Bundles the project as a distribution. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application.distZip - Bundles the project as a distribution. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application.installDist - Installs the project as a distribution as-is. [jar] findMainClass startScripts - Creates OS specific scripts to run the project as a JVM application. eclipse插件taskIDE taskscleanEclipse - Cleans all Eclipse files. cleanEclipseClasspath cleanEclipseJdt cleanEclipseProjecteclipse - Generates all Eclipse files. eclipseClasspath - Generates the Eclipse classpath file. eclipseJdt - Generates the Eclipse JDT settings file. eclipseProject - Generates the Eclipse project file. 生命周期之间的执行顺序test - Runs the unit tests. [classes, testClasses]中括号是他的前一阶段，执行他就会先执行前面的task，依次类推，就会找到他的执行顺序。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学用gradle搭建springboot项目]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%88%9D%E5%AD%A6gradle%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[安装gradle插件安装完成后，在开发工具中新建一个gradle项目;项目位置 编辑配置文件build.gradle作用相当于maven的pom123456789101112131415161718192021222324252627282930313233343536373839404142434445/*依赖的插件*/apply plugin: &apos;java&apos;apply plugin: &apos;eclipse&apos;apply plugin: &apos;spring-boot&apos;/*jdk版本*/sourceCompatibility = 1.8/*打包配置*/version = &apos;1.0&apos;jar &#123; manifest &#123; attributes &apos;Implementation-Title&apos;: &apos;Gradle Quickstart&apos;, &apos;Implementation-Version&apos;: version &#125;&#125;/*第三方库来源*/repositories &#123; mavenCentral()&#125;/*gradle 自身需要的依赖放在这里面，插件 就需要放在这里面*/buildscript &#123; ext &#123; springBootVersion = &quot;1.2.3.RELEASE&quot;&#125; repositories &#123; jcenter() /*是一个插件仓库，导入的插件将会在仓库中寻找并下载*/ &#125; dependencies &#123; /*必须配置，不然没法用springboot插件，脚本自身用的依赖都放到这里*/ classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;/*声明依赖*/dependencies &#123;/*这里是项目需要的依赖，也是有依赖范围的*/ compile &apos;org.springframework.boot:spring-boot:1.5.4.RELEASE&apos; compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.4.RELEASE&quot;) compile &apos;org.springframework.boot:spring-boot-autoconfigure:1.5.4.RELEASE&apos;&#125; spring-boot-gradle-plugin插件的task 分别用于打包和启动 task讲解1234567891011121314151617181920212223242526/*自定义的task，后面自定义构建玩一下，相当于maven里面的插件goal*/task testtask &#123; println &apos;哈哈哈哈&apos; /*每个task都有着两个方法*/ doLast &#123; println &apos;last&apos;&#125; doFirst &#123; println &apos;first&apos;&#125;&#125;/*task之间的依赖*/task testtask1(dependsOn:testtask) &#123; println &apos;哈哈哈哈1&apos;&#125;/* 覆盖java插件内置的task*/clean &#123;println &apos;测试clean，覆盖默认&apos;&#125;/*为task加组别和描述*/task addTask(group:&apos;测试组&apos;,description:&apos;task的描述&apos;)&#123;&#125; 查看task 命令查看所有的taks gradle -q tasks 查看所有的taks，一缩进方式显示依赖 gradle -q tasks –all gradle 执行顺序1.初始化阶段，会去读取根工程中setting.gradle中的include信息，决定有哪几个工程加入构建， 创建project实例，比如下面有三个工程： include ‘:app’, ‘:lib1’, ‘:lib2 2.配置阶段，会去执行所有工程的build.gradle脚本，配置project对象，一个对象由多个任务组成， 此阶段也会去创建、配置task及相关信息。 3.运行阶段，根据gradle命令传递过来的task名称，执行相关依赖任务 gradle task 命令执行任何一个task或者后面没有task，此时执行默认task，都会经历1 2 步骤，最后才执行相应的task中的action]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linu进程端口资源常用命令整理]]></title>
    <url>%2F2018%2F01%2F06%2Flinu%E8%BF%9B%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%B5%84%E6%BA%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[进程常用命令查看进程ps 查看所有进程 常用参数 ps aux ，ps -le-a 显示一个终端的所有进程，除了会话引线-u 显示进程的归属用户和内存适用情况-x 显示没有控制终端的进程-l 显示更加详细的信息-e 显示所有进程结果字段意思USER 所属用户PID 进程的唯一id%CPU 消耗cpu的百分比%MEM 消耗内存的百分比STAT 进程状态 START 运行开始时间TIME 占用cpu总时间 执行的命令VSZ(占用的虚拟内存) 单位都是kbRSS（占用的真是内存） 单位都是kbTTY，该进程是在那个终端中运行的。TTY1-TTY7是本地终端，TTY1-TTY6是字符界面终端，TTY7是图形界面终端，TTY/0-255是远程终端 常用 ps -ef | grep 程序名 选项含义如下：ps:将某个进程显示出来-A 显示所有程序。-e 此参数的效果和指定”A”参数相同。-f 显示UID,PPIP,C与STIME栏位。grep命令是查找中间的|是管道命令 是指ps命令与grep同时执行 字段含义如下UID PID PPID C STIME TTY TIME CMD各相关信息的意义：UID 程序被该 UID 所拥有PPID 则是其上级父程序的IDC CPU 使用的资源百分比STIME 系统启动时间 查看进程树pstree 显示进程树，以父子进程的关系显示，查看统一个服务有启动了几个进程特别方便-u 显示所属用户-p 显示pid 杀死进程杀死一个进程 kill -9 pid杀死一组进程 killall 进程名 端口查看命令netstat 查看端口是否开放-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命 telnet 探测端口是否可以访问到telnet ip port 查看系统资源查看内存适用情况free -[b|k|m|g] 查看硬盘使用情况df -[b|k|m]]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux操作文件]]></title>
    <url>%2F2018%2F01%2F04%2Flinux%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[编辑文件创建文件 vim 文件名编辑文件 vim 文件名编辑文件，输入 i 切换到插入模式保存文件 按esc切换到命令模式:wq 保存并退出 #查看文件ls 查看文件列表 （ll 就是 ls -l的别名）find 用来查找文件 删除文件夹rm -rf /var/log/httpd/access将会删除/var/log/httpd/access目录以及其下所有文件、文件夹 删除文件rm -f /var/log/httpd/access.log将会强制删除/var/log/httpd/access.log这个文件 复制文件[root@localhost share]# mkdir /usr/java/ // 在/usr目录下新建一个java目录[root@localhost share]# cp jdk-6u45-linux-i586.bin /usr/java/ // 将JDK文件复制 解压文件tar 命令-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 总结linux操作文件next主题的相关设置]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo初体验]]></title>
    <url>%2F2018%2F01%2F04%2Fhexo%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[要注意的问题，:后面需要一个空格端口占用情况markDown语法 文件修改后，执行下面两个命令相当于刷新$ hexo clean$ hexo s -g 链接示例 第二部分1234代码示例public static String getName() &#123; System.out.println(&quot;代码符号在左上角esc键下面！！！&quot;)&#125; 引用 狂人日记 粗体 无序列表 无序列表项1 无序列表项2 无序列表项3 有序列表写法：1.有序列表项12.有序列表项23.有序列表项3 测试a标签 红色测试 表格 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 og bird cat foo foo foo bar bar bar baz baz baz 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
